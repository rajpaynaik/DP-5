//Time O(NMK) and space O(N)
class Solution {
    HashMap<String, Boolean> map;
    public boolean wordBreak(String s, List<String> wordDict) {
        map = new HashMap<>();
        HashSet<String> set = new HashSet<>(wordDict);

        return helper(s,set);
        
    }

    public boolean helper(String s, HashSet<String> set){
        if(s.length()==0) return true;
        if(map.containsKey(s)) return map.get(s);


        for(int i=0;i<s.length();i++){
            String subStr = s.substring(0,i+1);
            String resStr = s.substring(i+1,s.length());

            if(set.contains(subStr)){
                if(helper(resStr,set)){
                    map.put(resStr,true);
                    return true;
                }else{
                    map.put(resStr,false);
                }
                
            }
        }

        return false;
    }
}

// O(N) and space O(N*M)
class Solution {
    public int uniquePaths(int m, int n) {

        int[][] dp = new int[m+1][n+1];

        dp[m-1][n-1] =1;
        for(int i=m-1;i>=0;i--){
            for(int j=n-1;j>=0;j--){
                if(i==m-1 && j==n-1) continue;
                dp[i][j] = dp[i+1][j] + dp[i][j+1];
            }
        }

        return dp[0][0];
        
    }
}
